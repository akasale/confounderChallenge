R
Rscript
;
ddd
reticulate::repl_python(quiet = TRUE, input = r"--(import pandas as pd
import numpy as np
# Set seed for reproducibility
np.random.seed(123)
# Create dataframe with 100 patients and severity scores
n_patients = 100
patients_df = (
    pd.DataFrame({
        'patient': range(1, n_patients + 1),
        'severity': np.random.normal(0, 1, n_patients)
    })
    .assign(
        # Assign doctors based on severity using sigmoid function:
        # Probability of Doc Duck is inversely proportional to severity
        # Higher severity → higher probability of Doc Duck
        # Uses sigmoid: P(Doc Duck) = 1 / (1 + exp(-k * severity))
        # where k controls the steepness of the relationship
        prob_duck=lambda df: 1 / (1 + np.exp(-1.5 * df['severity'])),  # k=1.5 controls sensitivity
        # Random assignment: if random < prob_duck → Doc Duck (id=0), else Doc Dreamy (id=1)
        doctor_id=lambda df: (np.random.random(n_patients) >= df['prob_duck']).astype(int),
        # Assign doctor names based on id
        doctor_name=lambda df: np.where(df['doctor_id'] == 1, 'Doc Dreamy', 'Doc Duck'),
        # Assign surgical goodness:
        # Doc Duck: Normal(0.2, 1), Doc Dreamy: Normal(-0.2, 1)
        surgicalGoodness=lambda df: np.where(
            df['doctor_name'] == 'Doc Duck',
            np.random.normal(0.5, 1, n_patients),
            np.random.normal(-0.4, 1, n_patients)
        ),
        # Calculate post-surgical severity: initial severity - surgical goodness + 3
        post_surgical_score=lambda df: df['severity'] - df['surgicalGoodness'] + 3
    )
)
# Save to CSV, excluding prob_duck and surgicalGoodness columns
patients_df[['patient', 'severity', 'doctor_id', 'doctor_name', 'post_surgical_score']].to_csv(
    'patients_data.csv', index=False
)
# Display first few rows
patients_df.head())--")
reticulate::repl_python(quiet = TRUE, input = r"--(import pandas as pd
import numpy as np
# Set seed for reproducibility
np.random.seed(123)
# Create dataframe with 100 patients and severity scores
n_patients = 100
patients_df = (
    pd.DataFrame({
        'patient': range(1, n_patients + 1),
        'severity': np.random.normal(0, 1, n_patients)
    })
    .assign(
        # Assign doctors based on severity using sigmoid function:
        # Probability of Doc Duck is inversely proportional to severity
        # Higher severity → higher probability of Doc Duck
        # Uses sigmoid: P(Doc Duck) = 1 / (1 + exp(-k * severity))
        # where k controls the steepness of the relationship
        prob_duck=lambda df: 1 / (1 + np.exp(-1.5 * df['severity'])),  # k=1.5 controls sensitivity
        # Random assignment: if random < prob_duck → Doc Duck (id=0), else Doc Dreamy (id=1)
        doctor_id=lambda df: (np.random.random(n_patients) >= df['prob_duck']).astype(int),
        # Assign doctor names based on id
        doctor_name=lambda df: np.where(df['doctor_id'] == 1, 'Doc Dreamy', 'Doc Duck'),
        # Assign surgical goodness:
        # Doc Duck: Normal(0.2, 1), Doc Dreamy: Normal(-0.2, 1)
        surgicalGoodness=lambda df: np.where(
            df['doctor_name'] == 'Doc Duck',
            np.random.normal(0.5, 1, n_patients),
            np.random.normal(-0.4, 1, n_patients)
        ),
        # Calculate post-surgical severity: initial severity - surgical goodness + 3
        post_surgical_score=lambda df: df['severity'] - df['surgicalGoodness'] + 3
    )
)
# Save to CSV, excluding prob_duck and surgicalGoodness columns
patients_df[['patient', 'severity', 'doctor_id', 'doctor_name', 'post_surgical_score']].to_csv(
    'patients_data.csv', index=False
)
# Display first few rows
patients_df.head())--")
reticulate::repl_python(quiet = TRUE, input = r"--(import pandas as pd
# Load the observational data
patients_df = pd.read_csv('patients_data.csv')
# Display first few rows to understand the structure
print(f"Number of patients: {len(patients_df)}")
patients_df.head())--")
# Load the observational data
patients_df <- read.csv('patients_data.csv')
# Display first few rows to understand the structure
cat("Number of patients:", nrow(patients_df), "\n")
head(patients_df)
reticulate::repl_python(quiet = TRUE, input = r"--(# TODO: Recover Figure 1 - Post-surgical outcomes by patient
# Load data (already loaded above)
# Create scatter plot with:
#   - Different markers for each doctor (circles vs triangles)
#   - Colorblind-friendly colors
#   - Mean lines and annotations
#   - Professional styling
# Hint: Use matplotlib object-oriented style (fig, ax = plt.subplots())
# Colors: Doc Dreamy = '#4E79A7' (blue), Doc Duck = '#E15759' (coral/red-orange))--")
# TODO: Recover Figure 1 - Post-surgical outcomes by patient
# Load data (already loaded above)
# Create scatter plot with ggplot2 or base R
# Include:
#   - Different shapes for each doctor
#   - Colorblind-friendly colors
#   - Mean lines and annotations
#   - Professional styling
# Hint: Use ggplot2 for professional plots
# Colors: Doc Dreamy = '#4E79A7' (blue), Doc Duck = '#E15759' (coral/red-orange)
reticulate::repl_python(quiet = TRUE, input = r"--(import pandas as pd
import numpy as np
# Set seed for reproducibility (different from observational data)
np.random.seed(456)
# Create dataframe with 100 patients and severity scores
n_patients_randomized = 100
patients_randomized_df = (
    pd.DataFrame({
        'patient': range(1, n_patients_randomized + 1),
        'severity': np.random.normal(0, 1, n_patients_randomized)
    })
    .assign(
        # Randomly assign doctors: 50/50 chance, independent of severity
        # This breaks the confounding relationship
        doctor_id=lambda df: np.random.choice([0, 1], size=n_patients_randomized),
        # Assign doctor names based on id
        doctor_name=lambda df: np.where(df['doctor_id'] == 1, 'Doc Dreamy', 'Doc Duck'),
        # Assign surgical goodness:
        # Doc Duck: Normal(0.5, 1), Doc Dreamy: Normal(-0.4, 1)
        # Same true effect as before - Doc Duck is better
        surgicalGoodness=lambda df: np.where(
            df['doctor_name'] == 'Doc Duck',
            np.random.normal(0.5, 1, n_patients_randomized),
            np.random.normal(-0.4, 1, n_patients_randomized)
        ),
        # Calculate post-surgical severity: initial severity - surgical goodness + 3
        post_surgical_score=lambda df: df['severity'] - df['surgicalGoodness'] + 3
    )
)
# Save to CSV, excluding surgicalGoodness column
patients_randomized_df[['patient', 'severity', 'doctor_id', 'doctor_name', 'post_surgical_score']].to_csv(
    'patients_data_randomized.csv', index=False
)
# Display first few rows
patients_randomized_df.head())--")
reticulate::repl_python(quiet = TRUE, input = r"--(import pandas as pd
# Load the randomized data
patients_randomized_df = pd.read_csv('patients_data_randomized.csv')
# Display first few rows
print(f"Number of randomized patients: {len(patients_randomized_df)}")
patients_randomized_df.head())--")
# Load the randomized data
patients_randomized_df <- read.csv('patients_data_randomized.csv')
# Display first few rows
cat("Number of randomized patients:", nrow(patients_randomized_df), "\n")
head(patients_randomized_df)
reticulate::repl_python(quiet = TRUE, input = r"--(# TODO: Recover Figure 2 - Randomized assignment outcomes
# Load randomized data (already loaded above)
# Create scatter plot similar to Figure 1
# Use same styling and color scheme
# Title: "Post-Surgical Symptom Score (Randomized Assignment)")--")
# TODO: Recover Figure 2 - Randomized assignment outcomes
# Load randomized data (already loaded above)
# Create scatter plot similar to Figure 1
# Use same styling and color scheme
# TODO: Recover Figure 2 - Randomized assignment outcomes
# Load randomized data (already loaded above)
# Create scatter plot similar to Figure 1
# Use same styling and color scheme
reticulate::repl_python(quiet = TRUE, input = r"--(# TODO: Recover Figure 3 - Outcomes by patient severity (stratification)
# Load observational data (already loaded above)
# Create scatter plot with:
#   - X-axis: Initial Patient Severity
#   - Y-axis: Post-Surgical Symptom Score
#   - Same color/marker scheme as previous figures
#   - Mean lines and annotations
#   - Shaded region from -1 to 1 on x-axis (use ax.axvspan or similar)
#   - Professional styling
# Hint: Use axvspan(-1, 1, alpha=0.15, color='gray', zorder=0) for the overlay)--")
